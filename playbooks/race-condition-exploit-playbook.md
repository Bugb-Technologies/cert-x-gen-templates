# Race Condition Detection (TOCTOU) - CERT-X-GEN Security Template

<div align="center">

![CERT-X-GEN](https://img.shields.io/badge/CERT--X--GEN-Security%20Template-00ADD8?style=for-the-badge&logo=go&logoColor=white)
![Severity](https://img.shields.io/badge/Severity-CRITICAL-red?style=for-the-badge)
![Language](https://img.shields.io/badge/Language-Go-00ADD8?style=for-the-badge&logo=go)
![CVSS](https://img.shields.io/badge/CVSS-8.1-red?style=for-the-badge)
![CWE](https://img.shields.io/badge/CWE-362%20|%20367%20|%20366-orange?style=for-the-badge)

**Detecting Time-Of-Check-Time-Of-Use vulnerabilities that traditional scanners miss**

*Race conditions are the silent killers of concurrent systems. A microsecond window can lead to duplicate transactions, bypassed rate limits, and compromised data integrity. CERT-X-GEN's Go-powered template uses goroutines for precise concurrent request analysis to expose these timing-dependent vulnerabilities before attackers do.*

</div>

---

## ğŸ“– Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Understanding Race Conditions](#2-understanding-race-conditions)
3. [Why Traditional Scanners Fail](#3-why-traditional-scanners-fail)
4. [The CERT-X-GEN Approach](#4-the-cert-x-gen-approach)
5. [Attack Flow Visualization](#5-attack-flow-visualization)
6. [Template Deep Dive](#6-template-deep-dive)
7. [Usage Guide](#7-usage-guide)
8. [Real-World Test Results](#8-real-world-test-results)
9. [Defense & Remediation](#9-defense--remediation)
10. [Extending the Template](#10-extending-the-template)
11. [References](#11-references)

---

## 1. Executive Summary

### What Are Race Conditions (TOCTOU)?

Race conditions, specifically **Time-Of-Check-Time-Of-Use (TOCTOU)** vulnerabilities, occur when an application checks a condition and then acts on it, but the state can change between the check and the action. In concurrent web applications, this timing window can be exploited by sending simultaneous requests that bypass security controls.

### Why This Matters

| Impact Area | Description | Real-World Example |
|------------|-------------|-------------------|
| **Financial Loss** | Duplicate transactions, coupon reuse | $1M+ stolen from Citibank ATMs via concurrent requests |
| **Rate Limit Bypass** | Circumvent API throttling, brute force protections | Instagram password reset vulnerability (Laxman Muthiyah) |
| **Data Integrity** | Inventory corruption, duplicate records | E-commerce flash sales selling same item multiple times |
| **Authentication Bypass** | Session fixation, token reuse | Authentication race conditions in web applications |
| **Privilege Escalation** | Account takeover, role manipulation | Concurrent requests exploiting username validation |

### Key Statistics

- **8.1 CVSS Score**: High severity security impact
- **CWE-362, 367, 366**: Multiple attack vectors
- **Concurrent Testing**: 20 simultaneous requests per endpoint
- **Sub-15s Detection**: Fast analysis using Go goroutines
- **Cloud-Scale Issue**: AWS DynamoDB outage (2025) caused by TOCTOU bug

### The CERT-X-GEN Advantage

Traditional scanners test sequentially and miss race conditions. This Go template leverages **goroutines** for precise concurrent request control, detecting timing-dependent vulnerabilities that only manifest under high concurrency.

---

## 2. Understanding Race Conditions

### The Core Problem

A race condition exists when:
1. **Multiple threads** access shared data
2. **At least one** performs a write operation
3. **No synchronization** protects the critical section

In web applications, each HTTP request typically runs in its own thread/process, creating natural concurrency.

### TOCTOU Attack Pattern

```
Time â†’  CHECK                    USE
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚   Race Window (gap)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘
        Attacker injects
        state change here
```

**Classic Example: Coupon Code Validation**

```python
# Vulnerable Code (Pseudocode)
def apply_coupon(code):
    if not is_used(code):        # â† CHECK (Time of Check)
        # Race window here!
        apply_discount()          # â† USE (Time of Use)
        mark_as_used(code)
 for single-use operations

#### Database Level

- [ ] **Enable ACID transactions**
- [ ] **Add unique constraints** on critical fields
- [ ] **Implement row-level locking** (SELECT FOR UPDATE)
- [ ] **Use database sequences** instead of application counters
- [ ] **Add CHECK constraints** for business logic

#### Infrastructure Level

- [ ] **Load balancer session affinity** (if needed)
- [ ] **Rate limiting at edge** (Cloudflare, AWS WAF)
- [ ] **Queue systems** for async processing
- [ ] **Circuit breakers** for cascading failures
- [ ] **Monitoring and alerting** for anomalies

### Framework-Specific Solutions

#### Django (Python)

```python
from django.db import transaction
from django.db.models import F

# Atomic transaction
@transaction.atomic
def use_coupon(code):
    coupon = Coupon.objects.select_for_update().get(code=code)
    if coupon.used:
        raise AlreadyUsed()
    coupon.used = True
    coupon.save()

# F() expressions for atomic updates
Product.objects.filter(id=product_id).update(
    stock=F('stock') - quantity
)
```

#### Flask (Python) with Redis

```python
import redis

r = redis.Redis()

def rate_limit(user_id, limit=10, window=3600):
    key = f"rate:{user_id}"
    pipe = r.pipeline()
    pipe.incr(key)
    pipe.expire(key, window)
    count, _ = pipe.execute()
    return count <= limit
```

#### Go with sync Package

```go
import "sync"

type SafeCounter struct {
    mu sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}
```

#### Node.js with Redis

```javascript
const redis = require('redis');
const client = redis.createClient();

async function useCoupon(code) {
    const key = `coupon:${code}`;
    // SETNX returns 1 if set, 0 if already exists
    const result = await client.setNX(key, 'used');
    return result === 1;
}
```

### Testing for Race Conditions

#### Manual Testing

```bash
# Use curl with & for concurrent execution
for i in {1..20}; do
    curl -X POST http://target.com/api/coupon \
         -H "Content-Type: application/json" \
         -d '{"code":"SAVE20"}' &
done
wait

# Check how many succeeded
```

#### Automated Testing (Python)

```python
import concurrent.futures
import requests

def test_race_condition(url, data, threads=20):
    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        futures = [executor.submit(requests.post, url, json=data) 
                   for _ in range(threads)]
        results = [f.result() for f in futures]
    
    # Analyze results
    status_codes = [r.status_code for r in results]
    print(f"Status codes: {set(status_codes)}")
    print(f"Success count: {status_codes.count(200)}")
```

---

## 10. Extending the Template

### Customization Options

#### 1. Add Custom Endpoints

```go
// Add your application-specific endpoints
endpoints := []TestEndpoint{
    {
        Path:        "/api/purchase",
        Method:      "POST",
        ContentType: "application/json",
        Body:        `{"product_id":"123","quantity":1}`,
        Description: "Purchase endpoint",
    },
    {
        Path:        "/api/wallet/transfer",
        Method:      "POST",
        ContentType: "application/json",
        Body:        `{"to":"user2","amount":10}`,
        Description: "Money transfer",
    },
    {
        Path:        "/vote",
        Method:      "POST",
        ContentType: "application/x-www-form-urlencoded",
        Body:        "item_id=42",
        Description: "Voting endpoint",
    },
}
```

#### 2. Adjust Concurrency Level

```go
// For more aggressive testing
config := RaceTestConfig{
    ConcurrentRequests: 50,  // Up from 20
    Timeout:            30 * time.Second,
    UserAgent:          "CERT-X-GEN-Aggressive/1.0",
}

// For gentler testing (production systems)
config := RaceTestConfig{
    ConcurrentRequests: 10,  // Down from 20
    Timeout:            5 * time.Second,
    UserAgent:          "CERT-X-GEN-Gentle/1.0",
}
```

#### 3. Add Authentication

```go
// Bearer token authentication
req.Header.Set("Authorization", "Bearer " + os.Getenv("AUTH_TOKEN"))

// Cookie-based authentication
req.Header.Set("Cookie", "session=" + os.Getenv("SESSION_COOKIE"))

// Basic auth
req.SetBasicAuth(username, password)
```

#### 4. Custom Analysis Logic

```go
func analyzeCustomPattern(results []RequestResult) *Finding {
    // Example: Detect if any request got a different discount
    discounts := make(map[string]int)
    
    for _, result := range results {
        // Parse response body for discount amount
        discount := extractDiscount(result.Body)
        discounts[discount]++
    }
    
    // Multiple different discounts = race condition
    if len(discounts) > 1 {
        return &Finding{
            Severity: "critical",
            Title: "Race Condition in Discount Calculation",
            Evidence: map[string]interface{}{
                "discount_variations": discounts,
            },
        }
    }
    
    return nil
}
```

#### 5. Add Response Body Analysis

```go
// Current: Simple hash
result.BodyHash = fmt.Sprintf("%x", body[:min(32, len(body))])

// Enhanced: Full response parsing
type ResponseData struct {
    Success bool   `json:"success"`
    Message string `json:"message"`
    Balance float64 `json:"balance"`
}

var respData ResponseData
json.Unmarshal(body, &respData)

result.CustomData = map[string]interface{}{
    "success": respData.Success,
    "balance": respData.Balance,
}
```

### Integration Examples

#### 1. CI/CD Pipeline Integration

```yaml
# .github/workflows/security-scan.yml
name: Race Condition Security Scan

on:
  pull_request:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Install CXG CLI
        run: |
          npm install -g @cert-x-gen/cli
      
      - name: Run Race Condition Scan
        run: |
          cxg scan \
            --scope ${{ secrets.STAGING_URL }} \
            --templates race-condition-exploit.go \
            --output-format json \
            > race-scan-results.json
      
      - name: Check for Vulnerabilities
        run: |
          HIGH_COUNT=$(jq '[.findings[] | select(.severity == "high" or .severity == "critical")] | length' race-scan-results.json)
          if [ "$HIGH_COUNT" -gt 0 ]; then
            echo "Found $HIGH_COUNT high/critical race conditions!"
            exit 1
          fi
```

#### 2. Kubernetes CronJob

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: race-condition-scanner
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: scanner
            image: cert-x-gen/scanner:latest
            env:
            - name: TARGET_URL
              valueFrom:
                configMapKeyRef:
                  name: scan-config
                  key: target-url
            command:
            - /bin/sh
            - -c
            - |
              cxg scan \
                --scope $TARGET_URL \
                --templates race-condition-exploit.go \
                --output-format json \
                | jq '.findings[] | select(.severity=="high" or .severity=="critical")' \
                | curl -X POST https://alerts.company.com/webhook -d @-
          restartPolicy: OnFailure
```

#### 3. Monitoring Integration (Prometheus)

```go
// Add metrics to template
import "github.com/prometheus/client_golang/prometheus"

var (
    raceScansDone = prometheus.NewCounter(prometheus.CounterOpts{
        Name: "race_scans_total",
        Help: "Total race condition scans performed",
    })
    
    raceVulnsFound = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "race_vulnerabilities_found",
            Help: "Race conditions found by severity",
        },
        []string{"severity"},
    )
)

// In your scan function
raceScansDone.Inc()
if finding.Severity == "high" {
    raceVulnsFound.WithLabelValues("high").Inc()
}
```

### Advanced Modifications

#### 1. Add Timing Analysis

```go
type TimingAnalysis struct {
    MinResponseTime time.Duration
    MaxResponseTime time.Duration
    AvgResponseTime time.Duration
    StdDeviation    float64
}

func analyzeTimings(results []RequestResult) TimingAnalysis {
    var total time.Duration
    var times []time.Duration
    
    for _, r := range results {
        if r.Error == nil {
            times = append(times, r.ResponseTime)
            total += r.ResponseTime
        }
    }
    
    avg := total / time.Duration(len(times))
    
    // Calculate standard deviation
    var variance float64
    for _, t := range times {
        diff := float64(t - avg)
        variance += diff * diff
    }
    stdDev := math.Sqrt(variance / float64(len(times)))
    
    // Detect timing anomalies
    if stdDev > float64(avg) * 0.5 {
        // High variance = possible race condition
    }
    
    return TimingAnalysis{...}
}
```

#### 2. Add Header Analysis

```go
// Track rate limit headers across requests
type RateLimitTracking struct {
    Limits map[string][]string  // Track per-request limits
}

func analyzeRateLimits(results []RequestResult) *Finding {
    limits := make(map[string]int)
    
    for _, r := range results {
        if limit, ok := r.Headers["X-RateLimit-Remaining"]; ok {
            limits[limit]++
        }
    }
    
    // If we see different rate limit values, indicates race
    if len(limits) > 3 {
        return &Finding{
            Severity: "high",
            Title: "Rate Limit Race Condition Detected",
            Evidence: map[string]interface{}{
                "rate_limit_variations": limits,
            },
        }
    }
    
    return nil
}
```

#### 3. Add Stateful Testing

```go
// Test with session/state
func testStatefulRace(client *http.Client, target string) {
    // Step 1: Create session
    sessionResp, _ := client.Post(target+"/login", ...)
    sessionCookie := sessionResp.Cookies()[0]
    
    // Step 2: Test race with session
    var wg sync.WaitGroup
    startChan := make(chan struct{})
    
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            <-startChan
            
            req, _ := http.NewRequest("POST", target+"/action", ...)
            req.AddCookie(sessionCookie)  // Authenticated request
            resp, _ := client.Do(req)
            // Analyze...
        }()
    }
    
    close(startChan)
    wg.Wait()
}
```

---

## 11. References

### Research Papers

1. **"Race Condition Vulnerabilities in Web Applications"**  
   - Guardtime, 2024  
   - https://guardtime.com/blog/race-condition-vulnerabilities-in-web-applications

2. **"Time-of-check Time-of-use (TOCTOU) Race Conditions"**  
   - Carnegie Mellon University  
   - https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C

3. **"Exploiting Race Conditions in Web Applications"**  
   - PortSwigger Research  
   - https://portswigger.net/research/smashing-the-state-machine

### CVE Examples

| CVE ID | Description | Impact |
|--------|-------------|--------|
| CVE-2019-14271 | Docker copy race condition | Container escape |
| CVE-2016-5195 | Dirty COW (Linux kernel) | Privilege escalation |
| CVE-2021-25329 | Apache Tomcat race condition | Authentication bypass |
| CVE-2023-28879 | Shell race condition | Privilege escalation |

### Security Advisories

1. **AWS DynamoDB DNS Outage (2025)**  
   - TOCTOU in DNS management system  
   - Regional service failure

2. **Instagram Password Reset (Laxman Muthiyah)**  
   - Rate limit bypass via race condition  
   - $30,000 bug bounty

3. **Poloniex Exchange**  
   - Withdrawal race condition  
   - $97,000 stolen

### Technical Documentation

1. **CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization**  
   - https://cwe.mitre.org/data/definitions/362.html

2. **CWE-367: Time-of-check Time-of-use Race Condition**  
   - https://cwe.mitre.org/data/definitions/367.html

3. **OWASP: Race Conditions**  
   - https://owasp.org/www-community/vulnerabilities/Race_Conditions

4. **Go Concurrency Patterns**  
   - https://go.dev/blog/pipelines  
   - https://go.dev/blog/context

### Tools & Resources

1. **Turbo Intruder (Burp Suite Extension)**  
   - HTTP request race condition testing  
   - https://github.com/PortSwigger/turbo-intruder

2. **Race The Web**  
   - Concurrent request testing tool  
   - https://github.com/TheHackerDev/race-the-web

3. **Go Race Detector**  
   - Built-in tool: `go run -race`  
   - https://go.dev/doc/articles/race_detector

4. **CERT-X-GEN CLI**  
   - Template execution engine  
   - https://github.com/Bugb-Technologies/cert-x-gen

### Learning Resources

1. **"The Little Book of Semaphores"** by Allen Downey  
   - Free PDF on synchronization primitives

2. **"Concurrency in Go"** by Katherine Cox-Buday  
   - O'Reilly, comprehensive Go concurrency guide

3. **PortSwigger Academy: Race Conditions**  
   - https://portswigger.net/web-security/race-conditions  
   - Interactive labs and tutorials

4. **HackTricks: Race Condition**  
   - https://book.hacktricks.xyz/pentesting-web/race-condition  
   - Practical exploitation examples

### Community

- **CERT-X-GEN GitHub**: https://github.com/Bugb-Technologies/cert-x-gen
- **CERT-X-GEN Templates**: https://github.com/Bugb-Technologies/cert-x-gen-templates
- **Bug Bounty Programs**: HackerOne, Bugcrowd (search "race condition")
- **Discord**: Join security community discussions on concurrent vulnerabilities

---

<div align="center">

## ğŸ¯ Ready to Detect Race Conditions?

**Get Started:**
```bash
# Clone the templates repository
git clone https://github.com/Bugb-Technologies/cert-x-gen-templates.git
cd cert-x-gen-templates

# Run the template
go run templates/go/race-condition-exploit.go target.com 80

# Or use CXG CLI
cxg scan --scope target.com --templates race-condition-exploit.go
```

**Need Help?**
- ğŸ“– [Full Documentation](https://deepwiki.com/Bugb-Technologies/cert-x-gen)
- ğŸ’¬ [Community Discord](https://discord.gg/cert-x-gen)
- ğŸ› [Report Issues](https://github.com/Bugb-Technologies/cert-x-gen-templates/issues)
- ğŸ“§ [Email Support](mailto:security@cert-x-gen.io)

---

**Built with â¤ï¸ by the CERT-X-GEN Security Team**

*Race conditions don't sleep. Neither should your security testing.*

![CERT-X-GEN](https://img.shields.io/badge/CERT--X--GEN-Securing%20The%20Future-00ADD8?style=for-the-badge)

</div>
