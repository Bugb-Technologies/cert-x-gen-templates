package main

// @id: race-condition-exploit
// @name: Race Condition Detection (TOCTOU)
// @author: CERT-X-GEN Security Team
// @severity: critical
// @description: Detects Time-Of-Check-Time-Of-Use (TOCTOU) race conditions in web applications
// @tags: race-condition, toctou, concurrency, timing-attack, business-logic
// @cwe: CWE-362, CWE-367, CWE-366
// @cvss: 8.1
// @references: https://portswigger.net/web-security/race-conditions, https://cwe.mitre.org/data/definitions/362.html
// @confidence: 85
// @version: 1.0.0

/*
Race Condition Detection Template

This template detects Time-Of-Check-Time-Of-Use (TOCTOU) race condition vulnerabilities
in web applications by sending concurrent HTTP requests and analyzing response patterns.

DETECTION STRATEGY:
1. Identify endpoints that modify state (POST/PUT/DELETE)
2. Send concurrent requests targeting the same resource
3. Analyze responses for inconsistencies indicating race windows:
   - Different status codes
   - Duplicate resource creation
   - Rate limit bypasses
   - State corruption indicators

COMMON VULNERABLE PATTERNS:
- Coupon/promo code validation then application
- Rate limiting checks
- Inventory/stock checks before purchase
- Single-use token validation
- Vote/rating limits
- Account balance operations
- File upload size limits

WHY GO:
- Goroutines provide precise timing control
- Native concurrency primitives
- Fast HTTP client with connection reuse
- sync.WaitGroup for coordination

SAFETY NOTE:
This template performs DETECTION ONLY. It does not exploit race conditions
to gain unauthorized access or corrupt data. All tests are read-heavy and
minimize state changes.
*/

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
)

// Metadata structure for template information
var Metadata = map[string]interface{}{
	"id":   "race-condition-exploit",
	"name": "Race Condition Detection (TOCTOU)",
	"author": map[string]string{
		"name":  "CERT-X-GEN Security Team",
		"email": "security@cert-x-gen.io",
	},
	"severity":    "critical",
	"description": "Detects TOCTOU race conditions via concurrent request analysis",
	"tags":        []string{"race-condition", "toctou", "concurrency", "timing-attack", "business-logic"},
	"language":    "go",
	"confidence":  85,
	"cwe":         []string{"CWE-362", "CWE-367", "CWE-366"},
	"cvss":        8.1,
	"references": []string{
		"https://portswigger.net/web-security/race-conditions",
		"https://cwe.mitre.org/data/definitions/362.html",
		"https://owasp.org/www-community/vulnerabilities/Race_Conditions",
	},
}

// Finding represents a detected vulnerability
type Finding struct {
	Target       string                 `json:"target"`
	TemplateID   string                 `json:"template_id"`
	TemplateName string                 `json:"template_name"`
	Severity     string                 `json:"severity"`
	Confidence   int                    `json:"confidence"`
	Title        string                 `json:"title"`
	MatchedAt    string                 `json:"matched_at"`
	Description  string                 `json:"description"`
	Evidence     map[string]interface{} `json:"evidence"`
	Remediation  string                 `json:"remediation,omitempty"`
	CWEIDs       []string               `json:"cwe_ids,omitempty"`
	CVSSScore    float64                `json:"cvss_score,omitempty"`
	Tags         []string               `json:"tags"`
	Timestamp    string                 `json:"timestamp"`
}

// RequestResult holds the result of a single HTTP request
type RequestResult struct {
	StatusCode   int
	ResponseTime time.Duration
	BodyHash     string
	BodyLength   int
	Error        error
	Headers      map[string]string
}

// TestEndpoint represents an endpoint to test
type TestEndpoint struct {
	Path        string
	Method      string
	ContentType string
	Body        string
	Description string
}

// Configuration for race condition testing
type RaceTestConfig struct {
	ConcurrentRequests int
	Timeout            time.Duration
	UserAgent          string
}

// testRaceCondition performs the main race condition detection
func testRaceCondition(host string, port int, timeout time.Duration) []Finding {
	var findings []Finding
	target := fmt.Sprintf("%s:%d", host, port)

	// HTTP client with timeout and keep-alive
	client := &http.Client{
		Timeout: timeout,
		Transport: &http.Transport{
			TLSClientConfig:     &tls.Config{InsecureSkipVerify: true},
			MaxIdleConns:        100,
			MaxIdleConnsPerHost: 100,
			IdleConnTimeout:     90 * time.Second,
		},
	}

	// Test configuration
	config := RaceTestConfig{
		ConcurrentRequests: 20, // Number of concurrent requests
		Timeout:            timeout,
		UserAgent:          "CERT-X-GEN/1.0 (Race Condition Detector)",
	}

	// Define endpoints to test
	endpoints := []TestEndpoint{
		{
			Path:        "/api/validate",
			Method:      "POST",
			ContentType: "application/json",
			Body:        `{"action":"check"}`,
			Description: "Generic validation endpoint",
		},
		{
			Path:        "/login",
			Method:      "POST",
			ContentType: "application/x-www-form-urlencoded",
			Body:        "username=test&password=test",
			Description: "Authentication endpoint",
		},
		{
			Path:        "/",
			Method:      "GET",
			ContentType: "",
			Body:        "",
			Description: "Root endpoint",
		},
	}

	// Test each endpoint
	for _, endpoint := range endpoints {
		// Try HTTPS as well
		for _, scheme := range []string{"http", "https"} {
			testURL := fmt.Sprintf("%s://%s%s", scheme, target, endpoint.Path)

			results := sendConcurrentRequests(client, testURL, endpoint, config)

			// Analyze results for race condition indicators
			if len(results) > 0 {
				analysis := analyzeRaceConditionPatterns(results, testURL, endpoint)
				if analysis != nil {
					findings = append(findings, *analysis)
					// Found something, don't need to test both schemes
					break
				}
			}
		}
	}

	// If no vulnerability found, return info finding
	if len(findings) == 0 {
		findings = append(findings, Finding{
			Target:       target,
			TemplateID:   Metadata["id"].(string),
			TemplateName: Metadata["name"].(string),
			Severity:     "info",
			Confidence:   70,
			Title:        "No Race Condition Detected",
			MatchedAt:    "/",
			Description:  "Concurrent request testing completed. No obvious race condition vulnerabilities detected. This indicates proper synchronization or the tested endpoints may not be vulnerable to TOCTOU attacks.",
			Evidence: map[string]interface{}{
				"tests_performed":     len(endpoints) * 2, // http + https
				"concurrent_requests": config.ConcurrentRequests,
				"endpoints_tested":    getEndpointPaths(endpoints),
				"recommendation":      "Consider testing with authenticated sessions and application-specific workflows",
			},
			Tags:      Metadata["tags"].([]string),
			Timestamp: time.Now().UTC().Format(time.RFC3339),
		})
	}

	return findings
}

// sendConcurrentRequests sends multiple concurrent requests and collects results
func sendConcurrentRequests(client *http.Client, targetURL string, endpoint TestEndpoint, config RaceTestConfig) []RequestResult {
	var wg sync.WaitGroup
	results := make([]RequestResult, config.ConcurrentRequests)

	// Synchronization channel to ensure all goroutines start simultaneously
	startChan := make(chan struct{})

	// Launch goroutines
	for i := 0; i < config.ConcurrentRequests; i++ {
		wg.Add(1)
		go func(index int) {
			defer wg.Done()

			// Wait for start signal
			<-startChan

			start := time.Now()
			result := RequestResult{
				Headers: make(map[string]string),
			}

			// Create request
			var req *http.Request
			var err error

			if endpoint.Body != "" {
				req, err = http.NewRequest(endpoint.Method, targetURL, strings.NewReader(endpoint.Body))
			} else {
				req, err = http.NewRequest(endpoint.Method, targetURL, nil)
			}

			if err != nil {
				result.Error = err
				results[index] = result
				return
			}

			// Set headers
			req.Header.Set("User-Agent", config.UserAgent)
			if endpoint.ContentType != "" {
				req.Header.Set("Content-Type", endpoint.ContentType)
			}

			// Send request
			resp, err := client.Do(req)
			if err != nil {
				result.Error = err
				result.ResponseTime = time.Since(start)
				results[index] = result
				return
			}
			defer resp.Body.Close()

			// Read response
			body, err := io.ReadAll(resp.Body)
			if err != nil {
				result.Error = err
				results[index] = result
				return
			}

			// Store result
			result.StatusCode = resp.StatusCode
			result.ResponseTime = time.Since(start)
			result.BodyLength = len(body)
			result.BodyHash = fmt.Sprintf("%x", body[:min(32, len(body))]) // First 32 bytes as simple hash

			// Capture interesting headers
			for _, header := range []string{"X-RateLimit-Remaining", "X-Request-ID", "Set-Cookie"} {
				if val := resp.Header.Get(header); val != "" {
					result.Headers[header] = val
				}
			}

			results[index] = result
		}(i)
	}

	// Small delay to ensure all goroutines are ready
	time.Sleep(10 * time.Millisecond)

	// Start all requests simultaneously
	close(startChan)

	// Wait for completion
	wg.Wait()

	return results
}

// analyzeRaceConditionPatterns analyzes request results for race condition indicators
func analyzeRaceConditionPatterns(results []RequestResult, targetURL string, endpoint TestEndpoint) *Finding {
	if len(results) == 0 {
		return nil
	}

	// Count patterns
	statusCodes := make(map[int]int)
	responseHashes := make(map[string]int)
	var totalTime time.Duration
	var successCount int
	var errorCount int

	for _, result := range results {
		if result.Error != nil {
			errorCount++
			continue
		}
		successCount++
		statusCodes[result.StatusCode]++
		responseHashes[result.BodyHash]++
		totalTime += result.ResponseTime
	}

	// Check for race condition indicators

	// 1. Multiple different status codes (unexpected variation)
	if len(statusCodes) > 2 {
		parsedURL, _ := url.Parse(targetURL)
		return &Finding{
			Target:       parsedURL.Host,
			TemplateID:   Metadata["id"].(string),
			TemplateName: Metadata["name"].(string),
			Severity:     "high",
			Confidence:   75,
			Title:        "Potential Race Condition - Inconsistent Response Patterns",
			MatchedAt:    endpoint.Path,
			Description:  fmt.Sprintf("Concurrent requests to %s endpoint showed inconsistent response patterns with %d different status codes. This may indicate a race condition where requests are processed in an unpredictable order, potentially allowing TOCTOU exploitation.", endpoint.Description, len(statusCodes)),
			Evidence: map[string]interface{}{
				"endpoint":                 endpoint.Path,
				"method":                   endpoint.Method,
				"concurrent_requests":      len(results),
				"status_code_distribution": statusCodes,
				"unique_responses":         len(responseHashes),
				"avg_response_time_ms":     totalTime.Milliseconds() / int64(successCount),
				"pattern":                  "status_code_variance",
			},
			Remediation: "Implement proper locking/synchronization mechanisms (mutexes, database transactions, optimistic locking) to ensure atomic check-then-act operations. Use database-level constraints where possible.",
			CWEIDs:      Metadata["cwe"].([]string),
			CVSSScore:   Metadata["cvss"].(float64),
			Tags:        Metadata["tags"].([]string),
			Timestamp:   time.Now().UTC().Format(time.RFC3339),
		}
	}

	// 2. High success rate with multiple unique responses (potential state corruption)
	if float64(len(responseHashes))/float64(successCount) > 0.3 && successCount > 10 {
		parsedURL, _ := url.Parse(targetURL)
		return &Finding{
			Target:       parsedURL.Host,
			TemplateID:   Metadata["id"].(string),
			TemplateName: Metadata["name"].(string),
			Severity:     "medium",
			Confidence:   70,
			Title:        "Possible Race Condition - Response Variation",
			MatchedAt:    endpoint.Path,
			Description:  fmt.Sprintf("Detected %d unique response patterns from %d concurrent requests to %s. This variation suggests potential race condition susceptibility where concurrent operations may not be properly serialized.", len(responseHashes), successCount, endpoint.Description),
			Evidence: map[string]interface{}{
				"endpoint":            endpoint.Path,
				"method":              endpoint.Method,
				"concurrent_requests": len(results),
				"successful_requests": successCount,
				"unique_responses":    len(responseHashes),
				"variation_ratio":     fmt.Sprintf("%.2f", float64(len(responseHashes))/float64(successCount)),
				"pattern":             "response_variation",
			},
			Remediation: "Review the endpoint's concurrency handling. Ensure that shared resources are protected with appropriate synchronization primitives. Consider using database-level locking or optimistic concurrency control.",
			CWEIDs:      Metadata["cwe"].([]string),
			CVSSScore:   7.2,
			Tags:        Metadata["tags"].([]string),
			Timestamp:   time.Now().UTC().Format(time.RFC3339),
		}
	}

	// No clear race condition detected
	return nil
}

// Helper functions

func getEndpointPaths(endpoints []TestEndpoint) []string {
	paths := make([]string, len(endpoints))
	for i, ep := range endpoints {
		paths[i] = fmt.Sprintf("%s %s", ep.Method, ep.Path)
	}
	return paths
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	var host string
	var port int

	// Check if running in engine mode
	if os.Getenv("CERT_X_GEN_MODE") == "engine" {
		host = os.Getenv("CERT_X_GEN_TARGET_HOST")
		portStr := os.Getenv("CERT_X_GEN_TARGET_PORT")
		if portStr == "" {
			portStr = "80"
		}
		fmt.Sscanf(portStr, "%d", &port)

		if host == "" {
			result := map[string]interface{}{
				"error": "CERT_X_GEN_TARGET_HOST not set",
			}
			jsonData, _ := json.Marshal(result)
			fmt.Println(string(jsonData))
			os.Exit(1)
		}
	} else {
		// CLI mode
		if len(os.Args) < 2 {
			result := map[string]interface{}{
				"error": "Usage: race-condition-exploit <host> [port]",
			}
			jsonData, _ := json.Marshal(result)
			fmt.Println(string(jsonData))
			os.Exit(1)
		}

		host = os.Args[1]
		port = 80
		if len(os.Args) > 2 {
			fmt.Sscanf(os.Args[2], "%d", &port)
		}
	}

	// Run detection with 15 second timeout
	findings := testRaceCondition(host, port, 15*time.Second)

	// Output JSON
	result := map[string]interface{}{
		"findings": findings,
		"metadata": Metadata,
	}

	jsonData, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error marshaling JSON: %v\n", err)
		os.Exit(1)
	}

	fmt.Println(string(jsonData))
}
